Only in aund-1.00: .DS_Store
Only in aund-1.00: .deps
Only in aund-1.00: Makefile
diff -up aund-0.01/aun.c aund-1.00/aun.c
--- aund-0.01/aun.c	2010-04-19 21:57:03.000000000 +0100
+++ aund-1.00/aun.c	2010-11-19 11:02:34.000000000 +0000
@@ -70,6 +70,7 @@ aun_setup(void)
 	sock = socket(AF_INET, SOCK_DGRAM, 0);
 	if (sock < 0)
 		err(1, "socket");
+	memset(&name, 0, sizeof(name));
 	name.sin_family = AF_INET;
 	name.sin_addr.s_addr = INADDR_ANY;
 	name.sin_port = htons(PORT_AUN);
diff -up aund-0.01/aun.h aund-1.00/aun.h
--- aund-0.01/aun.h	2010-04-19 21:47:46.000000000 +0100
+++ aund-1.00/aun.h	2010-11-22 20:32:17.000000000 +0000
@@ -48,7 +48,7 @@ struct aun_packet {
 	uint8_t data[0]; /* actually more */
 };
 
-#define AUN_MAX_BLOCK 4096
+#define AUN_MAX_BLOCK 1024
 
 #define EC_PORT_FS 0x99
 #define EC_PORT_PS_STATUS_ENQ 0x9f
Only in aund-1.00: autom4te.cache
diff -up aund-0.01/beebem.c aund-1.00/beebem.c
--- aund-0.01/beebem.c	2010-04-19 23:59:46.000000000 +0100
+++ aund-1.00/beebem.c	2010-11-22 14:06:12.000000000 +0000
@@ -160,6 +160,7 @@ beebem_setup(void)
 	sock = socket(AF_INET, SOCK_DGRAM, 0);
 	if (sock < 0)
 		err(1, "socket");
+	memset(&name, 0, sizeof(name));
 	name.sin_family = AF_INET;
 	name.sin_addr = ec2ip[our_econet_addr].addr;
 	name.sin_port = htons(ec2ip[our_econet_addr].port);
Only in aund-1.00: beebem.old
Only in aund-1.00: config.h
Only in aund-1.00: config.log
Only in aund-1.00: config.status
Common subdirectories: aund-0.01/contrib and aund-1.00/contrib
Only in aund-1.00: file.txt
diff -up aund-0.01/fileserver.h aund-1.00/fileserver.h
--- aund-0.01/fileserver.h	2010-04-25 14:13:11.000000000 +0100
+++ aund-1.00/fileserver.h	2010-11-28 18:10:13.000000000 +0000
@@ -82,6 +82,7 @@ struct fs_client {
 	int nhandles;
 	struct fs_handle **handles; /* array of handles for this client */
 	char *login;
+	int priv;
 	struct fs_dir_cache dir_cache;
 };
 
@@ -181,6 +182,9 @@ struct user_funcs {
 	char *(*urd)(char const *);
 	int (*change)(char const *, char const *, char const *);
 	int (*set_opt4)(char const *, int);
+	int (*set_priv)(struct fs_client *, char const *, char const *);
+        int (*get_priv)(char const *);
+        int (*newuser)(struct fs_client *, char const *);
 };
 
 extern struct user_funcs const *userfuncs;
diff -up aund-0.01/fs_cli.c aund-1.00/fs_cli.c
--- aund-0.01/fs_cli.c	2010-04-25 19:01:59.000000000 +0100
+++ aund-1.00/fs_cli.c	2010-11-28 18:58:38.000000000 +0000
@@ -69,6 +69,7 @@ static fs_cmd_impl fs_cmd_load;
 static fs_cmd_impl fs_cmd_save;
 static fs_cmd_impl fs_cmd_sdisc;
 static fs_cmd_impl fs_cmd_pass;
+static fs_cmd_impl fs_cmd_priv;
 static fs_cmd_impl fs_cmd_rename;
 
 static int fs_cli_match(char *cmdline, char **tail, const struct fs_cmd *cmd);
@@ -86,6 +87,7 @@ static const struct fs_cmd cmd_tab[] = {
 	{"LOAD",	1, fs_cmd_load,		},
 	{"LOGOFF",	3, fs_cmd_bye,		},
 	{"PASS",      	1, fs_cmd_pass,		},
+ 	{"PRIV",	1, fs_cmd_priv,		},
 	{"RENAME",      1, fs_cmd_rename,	},
 	{"SAVE",	1, fs_cmd_save,		},
 	{"SDISC",      	3, fs_cmd_sdisc,	},
@@ -273,6 +275,8 @@ fs_cmd_i_am(struct fs_context *c, char *
 		return;
 	}
 	c->client->login = strdup(login);
+	c->client->priv = userfuncs->get_priv(c->client->login);
+        if (debug) printf("Cli: %s has %d\n", c->client->login, c->client->priv);
 	reply.std_tx.command_code = EC_FS_CC_LOGON;
 	reply.std_tx.return_code = EC_FS_RC_OK;
 	/*
@@ -289,6 +293,27 @@ fs_cmd_i_am(struct fs_context *c, char *
 }
 
 static void
+fs_cmd_priv(struct fs_context *c, char *tail)
+{
+	struct ec_fs_reply reply;
+	char *user, *priv;
+	user = fs_cli_getarg(&tail);
+	priv = fs_cli_getarg(&tail);
+	if (debug) printf("cli: priv request %s to '%s'\n",user,priv);
+        if (c->client == NULL) {
+		fs_error(c, 0xff, "Who are you?");
+		return;
+	}
+	if (userfuncs->set_priv(c->client, user, priv)) {
+		fs_err(c, EC_FS_E_NOPRIV); // Should be Priv??
+		return;
+	}
+	reply.command_code = EC_FS_CC_DONE;
+	reply.return_code = EC_FS_RC_OK;
+	fs_reply(c, &reply, sizeof(reply));
+}
+
+static void
 fs_cmd_pass(struct fs_context *c, char *tail)
 {
 	struct ec_fs_reply reply;
diff -up aund-0.01/fs_misc.c aund-1.00/fs_misc.c
--- aund-0.01/fs_misc.c	2010-04-25 14:27:18.000000000 +0100
+++ aund-1.00/fs_misc.c	2010-11-28 16:19:44.000000000 +0000
@@ -207,7 +207,12 @@ fs_get_info(struct fs_context *c)
 		strncpy(reply.dir_name, f->fts_name, sizeof(reply.dir_name));
 		strpad(reply.dir_name, ' ', sizeof(reply.dir_name));
 		/* XXX should check ownership. See also cat_header */
-		reply.dir_access = FS_DIR_ACCESS_PUBLIC;
+                if (c->client->priv == EC_FS_PRIV_SYST)
+		{
+		    reply.dir_access = FS_DIR_ACCESS_OWNER;
+		} else { 
+		    reply.dir_access = FS_DIR_ACCESS_PUBLIC;
+                }
 		reply.cycle = 0; /* XXX should fake */
 		fs_reply(c, &(reply.std_tx), sizeof(reply));
 	}
@@ -441,7 +446,12 @@ fs_cat_header(struct fs_context *c)
 	strpad(reply.dir_name, ' ', sizeof(reply.dir_name));
 
 	/* XXX should check ownership. See also EC_FS_GET_INFO_DIR */
-	reply.ownership[0] = 'P';
+ 	if (c->client->priv == EC_FS_PRIV_SYST) 
+	{
+	    reply.ownership[0] = 'O';
+	} else {
+            reply.ownership[0] = 'P';
+        }
 
 	memset(reply.space, ' ', sizeof(reply.space));
 	memset(reply.spaces, ' ', sizeof(reply.spaces));
@@ -514,7 +524,7 @@ fs_get_users_on(struct fs_context *c)
 		aunfuncs->get_stn(&ent->host, p);
 		p += 2;
 		p += sprintf(p, "%.10s\r", ent->login);
-		*p++ = 0;  /* all users are unprivileged */
+		*p++ = c->client->priv;  /* all users are unprivileged */
 		i++;
 	}
 	reply->nusers = i;
@@ -547,7 +557,7 @@ fs_get_user(struct fs_context *c)
 		fs_reply(c, &(reply.std_tx), sizeof(reply.std_tx));
 	} else {
 		aunfuncs->get_stn(&ent->host, reply.station);
-		reply.priv = 0;  /* all users are unprivileged */
+		reply.priv = ent->priv; /* Use priv from passwd file */  
 		fs_reply(c, &(reply.std_tx), sizeof(reply));
 	}
 }
diff -up aund-0.01/fs_proto.h aund-1.00/fs_proto.h
--- aund-0.01/fs_proto.h	2010-04-18 15:40:59.000000000 +0100
+++ aund-1.00/fs_proto.h	2010-11-22 08:22:52.000000000 +0000
@@ -60,6 +60,12 @@
 #define EC_FS_OPT4_RUN	2
 #define EC_FS_OPT4_EXEC	3
 
+/* Priv Modes */
+#define EC_FS_PRIV_NONE  0  /* Normal User */
+#define EC_FS_PRIV_FIXED 1  /* Level 4 Dunno */
+#define EC_FS_PRIV_LIMIT 2  /* MDFS Cant change passwd */
+#define EC_FS_PRIV_SYST  3  /* System User */	
+
 /*
  * Structures common to several calls.
  */
diff -up aund-0.01/pw.c aund-1.00/pw.c
--- aund-0.01/pw.c	2010-04-21 00:12:52.000000000 +0100
+++ aund-1.00/pw.c	2010-11-28 18:57:54.000000000 +0000
@@ -126,10 +126,10 @@ pw_close_rename(void)
 }
 
 static int
-pw_read_line(char **user, char **pw, char **urd, int *opt4)
+pw_read_line(char **user, char **pw, char **urd, char **priv, int *opt4)
 {
 	static char buffer[16384];
-	char *p, *q, *r;
+	char *p, *q, *r, *s;
 
 	errno = 0;
 	if (!fgets(buffer, sizeof(buffer), fp)) {
@@ -140,16 +140,21 @@ pw_read_line(char **user, char **pw, cha
 	pwline++;
 
 	buffer[strcspn(buffer, "\r\n")] = '\0';
+
+	if (debug) printf("PW:line:%s\n",buffer);
+
 	if ((p = strchr(buffer, ':')) == NULL ||
-	    (q = strchr(p+1, ':')) == NULL) {
+	    (q = strchr(p+1, ':')) == NULL    || 
+	    (s = strchr(q+1, ':')) == NULL) {   
 		warnx("%s:%d: malformatted line\n", pwfile, pwline);
 		return -1;
 	}
-
+    
 	*p++ = '\0';
 	*q++ = '\0';
+        *s++ = '\0';
 
-	r = strchr(q, ':');
+	r = strchr(s, ':'); 
 	if (r) {
 		*r++ = '\0';
 		*opt4 = atoi(r);
@@ -160,27 +165,28 @@ pw_read_line(char **user, char **pw, cha
 	*user = buffer;
 	*pw = p;
 	*urd = q;
-
+	*priv = s;
+	
 	return 0;
 }
 
 static void
-pw_write_line(char *user, char *pw, char *urd, int opt4)
+pw_write_line(char *user, char *pw, char *urd, char *priv, int opt4)
 {
 
-	fprintf(newfp, "%s:%s:%s:%d\n", user, pw, urd, opt4);
+	fprintf(newfp, "%s:%s:%s:%s:%d\n", user, pw, urd, priv, opt4);
 }
 
 static char *
 pw_validate(char *user, const char *pw, int *opt4)
 {
-	char *u, *p, *d;
+	char *u, *p, *d, *s;
 	char *ret;
 
 	if (pw_open(0) < 0)
 		return NULL;
 
-	while (pw_read_line(&u, &p, &d, opt4) == 0) {
+	while (pw_read_line(&u, &p, &d, &s, opt4) == 0) {
 		if (!strcasecmp(user, u)) {
 			int ok = 0;
 
@@ -207,13 +213,13 @@ pw_validate(char *user, const char *pw, 
 static char *
 pw_urd(char const *user)
 {
-	char *u, *p, *d;
+	char *u, *p, *d, *s;
 	int o4;
 
 	if (pw_open(1) < 0)
 		return NULL;
 
-	while (pw_read_line(&u, &p, &d, &o4) == 0) {
+	while (pw_read_line(&u, &p, &d, &s, &o4) == 0) {
 		if (!strcasecmp(user, u)) {
 			pw_close();
 			return strdup(d);
@@ -226,19 +232,25 @@ pw_urd(char const *user)
 static int
 pw_change(const char *user, const char *oldpw, const char *newpw)
 {
-	char *u, *p, *d;
+	char *u, *p, *d, *s;
 	int opt4;
 	int done = 0;
+	char salt[64];
+	char *cp;
+	struct timeval tv;
 
 	if (pw_open(1) < 0)
 		return -1;
 
-	while (pw_read_line(&u, &p, &d, &opt4) == 0) {
+	while (pw_read_line(&u, &p, &d, &s, &opt4) == 0) {
 		if (!done && !strcasecmp(user, u)) {
 			int ok = 0;
-			char salt[64];
-			char *cp;
-			struct timeval tv;
+			ok = !strcmp(s, "L");
+ 			if (ok) {   // User isnt allowed to change passwd
+			        pw_close();
+				return -1;
+			}
+			ok = 0;
 			if (*p) {
 				cp = crypt(oldpw, p);
 				ok = !strcmp(cp, p);
@@ -255,7 +267,7 @@ pw_change(const char *user, const char *
 				tv.tv_usec & 0xFFFFFFFFUL);
 			p = crypt(newpw, salt);
 		}
-		pw_write_line(u, p, d, opt4);
+		pw_write_line(u, p, d, s, opt4);
 	}
 
 	return pw_close_rename();
@@ -264,23 +276,76 @@ pw_change(const char *user, const char *
 static int
 pw_set_opt4(const char *user, int newopt4)
 {
-	char *u, *p, *d;
+	char *u, *p, *d, *s;
 	int opt4;
 	int done = 0;
 
 	if (pw_open(1) < 0)
 		return -1;
 
-	while (pw_read_line(&u, &p, &d, &opt4) == 0) {
+	while (pw_read_line(&u, &p, &d, &s, &opt4) == 0) {
 		if (!done && !strcasecmp(user, u)) {
 		    opt4 = newopt4;
 		}
-		pw_write_line(u, p, d, opt4);
+		pw_write_line(u, p, d, s, opt4);
 	}
 
 	return pw_close_rename();
 }
 
+static int
+pw_get_priv(const char *user)
+{
+	char *u, *p, *d, *s;
+	int opt4;
+        int priv = EC_FS_PRIV_NONE; /* Assume no Priv */
+
+	if (pw_open(1) < 0)
+		return -1;
+
+        while (pw_read_line(&u, &p, &d, &s, &opt4) == 0) {
+                if (!strcasecmp(user, u)) {
+                        pw_close();
+			switch (*s) {
+                           case 'S': priv = EC_FS_PRIV_SYST; break;
+			   case 'L': priv = EC_FS_PRIV_LIMIT; break;
+			   case 'F': priv = EC_FS_PRIV_FIXED; break;
+
+			   default : priv = EC_FS_PRIV_NONE;
+			}
+  			if (debug) printf("get_priv: Priv level %d\n",priv);
+                        return priv;
+                }
+        }
+
+        pw_close();
+        return EC_FS_PRIV_NONE;
+}
+
+static int
+pw_set_priv( struct fs_client *client, const char *user, const char *newpriv)
+{
+        char *u, *p, *d, *s;
+        int opt4;
+        int done = 0;
+
+	if (client->priv == EC_FS_PRIV_SYST) {
+       	   if (pw_open(1) < 0)
+          	 return -1;
+
+           while (pw_read_line(&u, &p, &d, &s, &opt4) == 0) {
+                    if (!done && !strcasecmp(user, u)) {
+                        strcpy(s, newpriv);
+                    }
+                    pw_write_line(u, p, d, s, opt4);
+           }
+
+           return pw_close_rename();
+        }
+        return -1;  // No privilege
+}
+
 struct user_funcs const user_pw = {
-	pw_validate, pw_urd, pw_change, pw_set_opt4
+	pw_validate, pw_urd, pw_change, pw_set_opt4, pw_set_priv, pw_get_priv
+        
 };
Only in aund-1.00: stamp-h1
